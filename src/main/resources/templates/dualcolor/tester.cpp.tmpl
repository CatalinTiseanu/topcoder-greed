
#include <string>
#include <vector>
#include <iostream>
/*
*   Version 0.5
*  - Ansi color codes to make output easy to read.
*  - runTests needs a lot of arguments... 
*  - Feature complete.
* (c) 2013 Victor Hugo Soliz Kuncar, ZLIB/LibPNG license 
*
*/

using namespace std;

namespace Tester {

// Name the color codes:
const string COLOR_RESET  = "\\033[0m";    

const string BRIGHT_GREEN   = "\\033[1;32m";
const string BRIGHT_RED     = "\\033[1;31m";
const string NORMAL_CROSSED = "\\033[0;9;37m";
const string RED_BACKGROUND = "\\033[1;41m";
const string NORMAL_FAINT   = "\\033[0;2m";
const string BRIGHT_CYAN    = "\\033[1;36m";

// Configuration:
const int    BAR_LENGTH = 73; //length of the bar === that separates test cases
const string BAR_COLOR    = NORMAL_FAINT;  //The bar ====
const string TEST_COLOR   = BRIGHT_CYAN; //Color for the word "Test"

const string GRADE_COLOR[] = {
    RED_BACKGROUND, // bad (overall), 
    BRIGHT_RED,   // bad (case),
    COLOR_RESET,  // neutral
    BRIGHT_GREEN  // good
};

const map<char, string> RESULT_COLOR = {
    {'+' , BRIGHT_GREEN},
    {'X' , BRIGHT_RED},
    {'T' , BRIGHT_RED},
    {'?' , COLOR_RESET},
    {'d' , NORMAL_CROSSED},
};

/*==============================================================================
   output struct, holds the expected result of execution or is marked as an
   unknown result */
template<typename T> struct output {
    T value; bool u=false;
    
    output(T value) { this->value = value; }
    output() { u = true; }
};

/*==============================================================================
  Converts given argument into a string containing pretty-looking output
*/
string pretty(string s)
{
    return "\\"" + s + "\\"";
}
string pretty(double x)
{
    ostringstream s;
    s.precision(10);
    s << x;
    return s.str();
}
template <typename T> string pretty(T t) {
    ostringstream s;
    s << t;
    return s.str();
}
template <typename T> string pretty(vector<T> t)
{
    ostringstream s;
    s << "{";
    for (int i=0; i<t.size(); i++) {
        s << (i?",":"") << pretty(t[i]);
    }
    s << "}";
    return s.str();
}

/*==============================================================================
  Prints a test case's argument list
  
  printArgs(a,b,c) ->  cout << "[" << pretty(a) <<","<< pretty(b) <<"," <<  pretty(c) <<"]"
*/
void printArgsCont() {}

template<typename T, typename... Args> void printArgsCont(T value, Args... args)
{
    cout << "," << pretty(value);
    printArgsCont(args...);
}

template<typename T, typename... Args> void printArgs(T value, Args... args)
{
    cout << "[" << pretty(value);
    printArgsCont(args...);
    cout << "]";
}

/*==============================================================================
 tc_eq compares two values using TopCoder's rules. Mostly to allow floating 
 point comparison using absolute/relative error
    
*/
bool tc_eq(const double &a, const double &b)
{
    return (a==a) && (b==b) && fabs(a - b) <= 1e-9 * max(1.0, fabs(a));
}
template<typename T> bool tc_eq(const T &a, const T &b)
{
    return a == b;
}
template<typename T> bool tc_eq(const vector<T> &a, const vector<T> &b)
{
    if (a.size() != b.size()) {
        return false;
    }
    for (int i = 0; i < a.size(); i++) {
        if (! tc_eq(a[i], b[i])) {
            return false;
        }
    }
    return true;
}

/*==============================================================================
   Add color to a string according to grade q. -2 is worst, 1 is good.
*/   
string colorString(string s, int q)
{
    return GRADE_COLOR[q+2] + s + COLOR_RESET;
}
string colorTestResult(char r)
{
    return RESULT_COLOR.at(r) + r + COLOR_RESET;
};

/*==============================================================================
   Print a double value using two decimals
*/
string f02(double x)
{
    ostringstream s;
    s.precision(2);
    s << fixed <<x;
    return s.str();
}

/*==============================================================================
   Prints case number i if there are n test cases in total. So it uses the
   correct width.
*/
string caseNum(int i, int n) {
    ostringstream ss;
    int w =  max<int>(1, to_string(n-1).length() );
    ss << setw(w) << i;
    return ss.str();
}


/*==============================================================================
    Returns the name of a type in human-readable form. It likely only works 100%
    correctly with classes that don't belong to a namespace and is not very
    portable.
*/
template<typename T> string getTypeName()
{
    string s = typeid(T).name();
    int i= 0; 
    while ( (i < s.size()) && ('0' <= s[i] && s[i] <= '9') ) {
        i++;
    }
    return s.substr(i);
}

/** =============================================================================
    runTestCase tests a single case.
    
    Template arguments:
    @arg input       : The class that stores input.
    @arg output      : The class that stores output.
    @arg problemClass: The class name for the problem.
    
    Normal arguments:
    @arg caseNo    : The test case's index
    @arg in        : The test case's input
    @arg exp       : The test case's expected output
    @arg n         : The number of testcases
    @arg timeOut   : The maximum time available for the test case.
    
    Output arguments:
    @arg finalLines: Vector that countains the results card that is shown at the 
                     end of tests.
    
    The return is one of:
    + : Correct.
    X : Wrong answer.
    T : Correct but time exceeded T
    ? : Executed correctly, there is no expected output so we can't know if it 
        is correct

*/
template<typename input, typename output, typename problemClass>
char runTestCase(int caseNo, input in, output exp, int n, double timeOut, vector<string> & finalLines) {
    cout << TEST_COLOR << "Test " << caseNo << COLOR_RESET <<": ";
    in.print();
    cout << endl;

    time_t s = clock();
    problemClass* instance = new problemClass();
    output res = output( in.run(instance) );
    double elapsed = (double)(clock() - s) / CLOCKS_PER_SEC;
    delete instance;
    
    cout << "Time: "<< f02(elapsed)<<" seconds." << endl;

    bool correct = exp.u || tc_eq(exp.value, res.value);

    if (! correct) {
        cout << "Desired answer:" << endl;
        cout << "\\t" << pretty(exp.value) << endl;
    }
    cout << "Your answer:" << endl;
    cout << "\\t" << pretty(res.value) << endl;

    string ln = TEST_COLOR + "t" + caseNum(caseNo,n) +":";

    char ret = '-';
    if (! correct) {
        ret = 'X';
    } else if (elapsed > timeOut ) {
        ret = 'T';
    } else if (exp.u) {
        ret = '?';
    } else {
        ret = '+';
    }
    string tm = " " + colorTestResult(ret);
    cout << tm;
    ln += tm + " (" + f02(elapsed) + "s)"; 
    cout << endl << BAR_COLOR << string(BAR_LENGTH,'=') << COLOR_RESET << endl;
    if (ret == 'X' || ret == '?') {
        ln += " [" + pretty(res.value)+"]";
    }
    finalLines.push_back(ln);
    return ret;
}

/** =============================================================================
    runTests tests a sequence of test cases, outputs results.
    
    Template arguments:
    @arg problemClass: The class name for the problem.
    @arg input       : The class that stores input.
    @arg output      : The class that stores output.
    
    Normal arguments:
    @arg testCases   : A vector of test cases, a test case is a (input,output) pair.
    @arg disabled    : A function takes integer returns boolean. If disabled(i) then
                       the i-th test case is disabled.
    @arg score       : The score of the problem (e.g: 250)
    @arg openTime    : The time in which the problem was opened, used to calculate
                       submission score.
    @arg caseTimeOut : The maximum time available for each  test case.
    @arg compact     : Use compact output.

    The return is a program exit code.

*/
template<typename problemClass, typename input, typename output> 
int runTests(vector<pair<input,output>> testCases, function<bool(int)> disabled, int score, int openTime, double caseTimeOut, bool compact)
{
    string result;
    vector<string> finalLines;
    int n = testCases.size();
    for (int i = 0; i < n; i++) {
        char ch = 'd';
        if (disabled(i)) {
            finalLines.push_back( TEST_COLOR + "t" + caseNum(i, n)+ COLOR_RESET + ": "+colorTestResult('d'));
        } else {
            ch = runTestCase<input,output,problemClass>(
                i, testCases[i].first, testCases[i].second,
                n, caseTimeOut, finalLines
            );
        }
        result += ch; 
    }
    cout << getTypeName<problemClass>() << ( compact ? ": " : "\\n\\n" );
    bool good = true;
    for (char ch: result) {
        good &= ( ch == '?' || ch == '+' );
        if (compact) {
            cout << colorTestResult(ch) << " ";
        }
    }
    if ( ! compact) {
        for (string ln : finalLines) {
            cout << " " << ln << endl;
        }
    }

    int T = time(NULL) - openTime;
    double PT = T / 60.0, TT = 75.0, SS = score * (0.3 + (0.7 * TT * TT) / (10.0 * PT * PT + TT * TT));
    string SSS = Tester::f02(SS);
    cout << ( !compact? "\\n" : "(") << colorString(SSS, good? 1 : -2) << ( compact?").":"") << endl;
    return 0;
}

}
